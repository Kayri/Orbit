package com.mehdiatique.feature.notes.presentation.details

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.mehdiatique.core.data.model.Contact
import com.mehdiatique.core.data.model.Note
import com.mehdiatique.core.data.repository.ContactRepository
import com.mehdiatique.core.data.repository.NoteRepository
import com.mehdiatique.core.navigation_contract.NotesNav
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.flatMapLatest
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.onStart
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

/**
 * ViewModel for managing note creation, editing, and viewing logic.
 *
 * Handles loading of existing notes, form updates, saving, and one-time UI events
 * such as navigation or showing messages.
 */
@HiltViewModel
class NoteDetailViewModel @Inject constructor(
    private val contactRepository: ContactRepository,
    private val noteRepository: NoteRepository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val noteId: Long? = savedStateHandle.get<String>(NotesNav.ARG_NOTE_ID)?.toLong()
    private val ownerId: Long? = savedStateHandle.get<String>(NotesNav.ARG_CONTACT_ID)?.toLong()

    private val _state = MutableStateFlow(
        NoteDetailState(
            note = Note(
                id = noteId ?: TEMP_ID, // Auto-generated by Room
                createdAt = System.currentTimeMillis(),
                owner = ownerId?.let { Contact(id = it) }
            ),
            mode = if (noteId == null) NoteDetailMode.ADD else NoteDetailMode.VIEW,
            isLoading = noteId != null
        )
    )
    val state: StateFlow<NoteDetailState> = _state

    private val _uiEvent = MutableSharedFlow<NoteDetailUiEvent>()
    val uiEvent: SharedFlow<NoteDetailUiEvent> = _uiEvent

    init {
        noteId?.let { id -> observeNoteDetails(id) }
    }

    /**
     * Handles user-driven events such as field changes, save, and cancel actions.
     *
     * @param event The event to process.
     */
    fun onEvent(event: NoteDetailEvent) {
        when (event) {
            is NoteDetailEvent.ContentChanged -> updateNote { it.copy(content = event.content) }
            is NoteDetailEvent.TitleChanged -> updateNote { it.copy(title = event.title) }
            is NoteDetailEvent.ContactChanged -> event.contactId?.let { id -> updateNote { it.copy(owner = Contact(id = id)) } }
            is NoteDetailEvent.CloseEdit -> _state.update { it.copy(mode = NoteDetailMode.VIEW) }
            is NoteDetailEvent.EditNote -> _state.update { it.copy(mode = NoteDetailMode.EDIT) }
            is NoteDetailEvent.SaveNote -> saveNote()
            is NoteDetailEvent.ErrorShown -> _state.update { it.copy(error = null) }
            is NoteDetailEvent.LoadAllContacts -> loadAllContacts()
            is NoteDetailEvent.OpenContact -> onUiEvent(NoteDetailUiEvent.NavigateToContact(event.contactId))
        }
    }

    /**
     * Handles One-time UI events such as closing the screen, confirming a save,
     * or navigating to related features like tasks or notes.
     *
     * @param event The event to process.
     */
    fun onUiEvent(event: NoteDetailUiEvent) {
        viewModelScope.launch {
            _uiEvent.emit(event)
        }
    }

    private fun observeNoteDetails(noteId: Long) {
        viewModelScope.launch {
            noteDetailFlow(noteId = noteId)
                .onStart { _state.update { it.copy(isLoading = true) } }
                .catch { e ->
                    _state.update {
                        it.copy(
                            isLoading = false,
                            error = e.message ?: e.cause?.message ?: "Unknown error"
                        )
                    }
                }
                .collect { note ->
                    _state.update { it.copy(note = note, isLoading = false) }
                }
        }
    }

    @OptIn(ExperimentalCoroutinesApi::class)
    private fun noteDetailFlow(noteId: Long): Flow<Note> =
        noteRepository.getNoteById(noteId).flatMapLatest { note ->
            val ownerId = note.owner?.id
            if (ownerId != null) {
                contactRepository.getContactById(ownerId).map { owner ->
                    note.copy(owner = owner)
                }
                /*Todo :
                   combine(
                    contactRepository.getContactById(ownerId),
                    taskRepository.getTasksForNoteId(noteId)
                ) { owner, task ->
                    note.copy(owner = owner, task = task)
                }*/
            } else {
                flowOf(note)
            }
        }

    private fun loadAllContacts() {
        if (_state.value.contacts.isEmpty()) {
            viewModelScope.launch {
                contactRepository.getAllContacts().collect { contacts ->
                    _state.update { it.copy(contacts = contacts) }
                }
            }
        }
    }

    private fun updateNote(modify: (Note) -> Note) {
        val currentNote = _state.value.note
        _state.update {
            it.copy(note = modify(currentNote.copy(updatedAt = System.currentTimeMillis())))
        }
    }

    private fun saveNote() {
        val note = _state.value.note
        viewModelScope.launch {
            try {
                if (note.id == TEMP_ID) {
                    val newId = noteRepository.addNote(note)
                    // Reload to fetch Owner Name
                    observeNoteDetails(newId)
                } else {
                    noteRepository.updateNote(note)
                }
                onUiEvent(NoteDetailUiEvent.NoteSaved)
            } catch (e: Exception) {
                _state.update { it.copy(error = e.message ?: e.cause?.message ?: "Unknown error") }
            }
        }
    }

    companion object {
        private const val TEMP_ID = 0L
    }
}
