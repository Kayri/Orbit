package com.mehdiatique.feature.tasks.presentation.details

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.mehdiatique.core.data.model.Contact
import com.mehdiatique.core.data.model.Task
import com.mehdiatique.core.data.repository.ContactRepository
import com.mehdiatique.core.data.repository.NoteRepository
import com.mehdiatique.core.data.repository.TaskRepository
import com.mehdiatique.core.navigation_contract.TasksNav
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.flatMapLatest
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.flow.onStart
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

/**
 * ViewModel for managing task creation, editing, and viewing logic.
 *
 * Handles loading of existing tasks, form updates, saving, and one-time UI events
 * such as navigation or showing messages.
 */
@HiltViewModel
class TaskDetailViewModel @Inject constructor(
    private val contactRepository: ContactRepository,
    private val noteRepository: NoteRepository,
    private val taskRepository: TaskRepository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val taskId: Long? = savedStateHandle.get<String>(TasksNav.ARG_TASK_ID)?.toLong()
    private val ownerId: Long? = savedStateHandle.get<String>(TasksNav.ARG_CONTACT_ID)?.toLong()

    private val _state = MutableStateFlow(
        TaskDetailState(
            task = Task(
                id = taskId ?: TEMP_ID, // Auto-generated by Room
                createdAt = System.currentTimeMillis(),
                owner = ownerId?.let { Contact(id = it) }
            ),
            mode = if (taskId == null) TaskDetailMode.ADD else TaskDetailMode.VIEW,
            isLoading = taskId != null
        )
    )
    val state: StateFlow<TaskDetailState> = _state

    private val _uiEvent = MutableSharedFlow<TaskDetailUiEvent>()
    val uiEvent: SharedFlow<TaskDetailUiEvent> = _uiEvent

    init {
        taskId?.let { id -> observeTaskDetails(id) }
    }

    /**
     * Handles user-driven events such as field changes, save, and cancel actions.
     *
     * @param event The event to process.
     */
    fun onEvent(event: TaskDetailEvent) {
        when (event) {
            is TaskDetailEvent.ContentChanged -> updateTask { it.copy(content = event.content) }
            is TaskDetailEvent.TitleChanged -> updateTask { it.copy(title = event.title) }
            is TaskDetailEvent.PriorityChanged -> updateTask { it.copy(priority = event.priority) }
            is TaskDetailEvent.ContactChanged -> event.contact?.let { contact -> updateTask { it.copy(owner = contact) } }
            is TaskDetailEvent.CloseEdit -> _state.update { it.copy(mode = TaskDetailMode.VIEW) }
            is TaskDetailEvent.EditTask -> _state.update { it.copy(mode = TaskDetailMode.EDIT) }
            is TaskDetailEvent.SaveTask -> saveTask()
            is TaskDetailEvent.ErrorShown -> _state.update { it.copy(error = null) }
            is TaskDetailEvent.LoadAllContacts -> loadAllContacts()
            is TaskDetailEvent.OpenContact -> onUiEvent(TaskDetailUiEvent.NavigateToContact(event.contactId))

        }
    }

    /**
     * Handles One-time UI events such as closing the screen, confirming a save,
     * or navigating to related features like tasks or tasks.
     *
     * @param event The event to process.
     */
    fun onUiEvent(event: TaskDetailUiEvent) {
        viewModelScope.launch {
            _uiEvent.emit(event)
        }
    }

    private fun observeTaskDetails(noteId: Long) {
        viewModelScope.launch {
            taskDetailFlow(noteId = noteId)
                .onStart { _state.update { it.copy(isLoading = true) } }
                .catch { e ->
                    _state.update {
                        it.copy(
                            isLoading = false,
                            error = e.message ?: e.cause?.message ?: "Unknown error"
                        )
                    }
                }
                .collect { task ->
                    _state.update { it.copy(task = task, isLoading = false) }
                }
        }
    }

    @OptIn(ExperimentalCoroutinesApi::class)
    private fun taskDetailFlow(noteId: Long): Flow<Task> =
        taskRepository.getTaskById(noteId).flatMapLatest { task ->
            val ownerId = task.owner?.id
            if (ownerId != null) {
                combine(
                    contactRepository.getContactById(ownerId),
                    noteRepository.getNoteById(task.id)
                ) { owner, note ->
                    task.copy(owner = owner, note = note)
                }
            } else {
                flowOf(task)
            }
        }

    private fun loadAllContacts() {
        viewModelScope.launch {
            contactRepository.getAllContacts()
                .catch { e ->
                    _state.update { it.copy(error = e.message ?: e.cause?.message ?: "Unknown error") }
                }
                .collect { contacts ->
                    _state.update { it.copy(contacts = contacts) }
                }
        }
    }

    private fun updateTask(modify: (Task) -> Task) {
        val currentTask = _state.value.task
        _state.update {
            it.copy(task = modify(currentTask.copy(updatedAt = System.currentTimeMillis())))
        }
    }

    private fun saveTask() {
        val task = _state.value.task
        viewModelScope.launch {
            try {
                if (task.id == TEMP_ID) {
                    val newId = taskRepository.addTask(task)
                    updateTask { it.copy(id = newId) }
                } else {
                    taskRepository.updateTask(task)
                }
                onUiEvent(TaskDetailUiEvent.TaskSaved)
            } catch (e: Exception) {
                _state.update { it.copy(error = e.message ?: e.cause?.message ?: "Unknown error") }
            }
        }
    }

    companion object {
        private const val TEMP_ID = 0L
    }
}
